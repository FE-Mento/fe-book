# 🎯 Chapter 3: HTTP 기본

## 🍄 1. 모든 것이 HTTP

### 🌻 1-1. HTTP 메시지에 모든 것을 전송

- HTTP는 Hyper Text Transfer Protocol의 약자이다.
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
- 지금은 **HTTP 시대**이다.

### 🌻 1-2. HTTP 역사

- HTTP/0.9
    - 1991년 등장
    - GET 메서드만 지원
    - HTTP 헤더 ❌
- HTTP/1.0
    - 1996년 등장
    - 메서드, 헤더 추가
- **HTTP/1.1**
    - 1997년 등장
    - 가장 많이 사용한다.
    - 가장 중요한 버전이다.
    - RFC2068(1997) → RFC2616(1999) → RFC7230~7235(2014)
- HTTP/2
    - 2015년 등장
    - 성능 개선
- HTTP/3
    - 현재 진행중
    - TCP 대신에 UDP 사용
    - 성능 개선

### 🌻 1-3. 기반 프로토콜

- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3
- 현재 HTTP/1.1 주로 사용한다.
    - HTTP/2, HTTP/3도 점점 증가하는 추세이다.
    - 2, 3은 성능 개선 버전이기 때문에 1만 잘 알아도 된다.

### 🌻 1-4. HTTP 특징

- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

## 🍄 2. 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.
- 서버가 요청에 대한 결과를 만들어서 응답한다.
- 이 구조를 통해 비즈니스 로직이랑 데이터는 서버에 넣고, 클라이언트는 UI 라던지 사용성에 집중 가능해졌다. 이로 인해 클라이언트와 서버가 각각 진화가 가능해졌다.

## 🍄 3. Stateful, Stateless

### 🌻 3-1. 무상태 프로토콜 스테이스리스(Stateless)

- 서버가 클라이언트의 상태를 보존 ❌
- 장점 : 서버 확장성 높음(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터 전송

### 🌻 3-2. Stateful, Stateless 예시

- Stateful은 상태를 유지하고 Stateless는 상태를 유지하지 않는다.
- Stateful 예시
    1. 고객이 점원에게 신발이 얼만지 물어본다.
    2. 점원은 고객에게 100만원이라고 말해준다.(신발가 상태 유지)
    3. 고객은 2개를 구매하겠다고 점원에게 말해준다.
    4. 점원은 200만원이라 하며 신용카드와 현금 중 어떤 걸로 구매 하냐고 고객에게 물어본다.(신발, 2개 상태 유지)
    5. 고객은 점원에게 신용카드를 건내준다.
    6. 점원은 신용카드로 결제한다.(신발, 2개, 신용카드 상태 유지)
- Stateful 예시 (중간에 점원이 바뀐다면)
    1. 고객이 점원에게 신발이 얼만지 물어본다.
    2. 점원은 고객에게 100만원이라고 말해준다.
    3. 고객은 2개를 구매하겠다고 점원에게 말해준다.
    4. 점원은 무엇을 2개 구매하냐고 고객에게 물어본다.
    5. 고객은 점원에게 신용카드를 건내준다.
    6. 점원은 무엇을 몇개 신용카드로 구매하냐고 고객에게 물어본다.
- Stateless 예시
    1. 고객은 이 신발이 얼만지 물어본다.
    2. 점원은 고객에게 100만원이라고 말해준다.
    3. 고객은 신발 2개를 구매하겠다고 점원에게 말해준다.
    4. 점원은 고객에게 신발 2개의 가격은 200만원이라고 말하며, 신용카드와 현금 중 어떤걸로 구매하냐고 묻는다.
    5. 고객은 신발 2개를 신용카드로 구매하겠다고 점원에게 말한다.
    6. 점원은 신용카드로 200만원을 결제한다.
- Stateful은 상태가 유지되지만 중간에 다른 점원으로 바뀌면 안된다.
- Stateless는 중간에 점원이 바뀌어도 시나리오가 변경되지 않는다.
    - 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
    - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.

### 🌻 3-3. Stateful, Stateless 차이 정리

- 무상태(Stateless)는 응답 서버를 쉽게 바꿀 수 있다. → **무한한 서버 증설 가능**
- Stateful은 항상 같은 서버가 유지되어야 한다.
- Stateful은 중간에 서버가 장애가 난다면 상태가 유지되지 않기 때문에 전체적인 서비스에 문제가 생긴다.(클라이언트는 전체적인 과정을 다시 반복해야 한다.)
- Stateless는 아무 서버나 호출해도 된다.
- Stateless는 중간에 서버가 장애가 난다면 다른 서버가 전달해준다.
- Stateless는 스케일 아웃(수평 확장)이 유리하다.

### 🌻 3-4. Stateless 실무 한계

- 모든 것을 무상태로 설계 할 수 있는 경우가 있을 수도 없을 수도 있다.
- 무상태
    - 예) 로그인이 필요 없는 단순한 서비스 소개 화면
- 상태 유지
    - 예) 로그인
- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태를 유지한다.
- 상태 유지는 최소한만 사용한다.
- Stateless는 데이터를 너무 많이 보내는 단점도 존재한다.

## 🍄 4. 비 연결성(connectionless)

### 🌻 4-1. 연결을 유지하는 모델

- 서버는 연결을 계속 유지해야 하며 서버 자원이 소모된다.

### 🌻 4-2. 연결을 유지하지 않는 모델

- 서버는 연결 유지 ❌
- 최소한의 자원 유지

### 🌻 4-3. 비 연결성이란

- HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답한다.
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.
    - 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있다.

### 🌻 4-4. 비 연결성의 한계와 극복

- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다.
- 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화
- HTTP 초기에는  HTML, 자바스크립트, 이미지를 요청할 때 하나씩 연결하고 응답받고 연결 종료하고를 반복하였지만, **HTTP 지속 연결**을 통하여 필요한 데이터를 요청하고 데이터를 응답받고 요청을 유지한다. 모든 요청에 대한 응답이 끝날때까지 연결을 유지하다가 모든 데이터를 응답받았으면 연결을 종료한다.

### 🌻 4-5. 스테이스리스를 기억하자

- 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
- 예) 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록
- 예) 저녁 6시 선착순 1000명 치킨 할인 이벤트 → 수만명 동시 요청
- 이런 경우에 최대한 Stateless하게 설계하는 것이 중요하다. 그러면 대용량 트래픽이 올때도 서버를 늘려서 대응하기 쉬워진다.

## 🍄 5. HTTP 메시지

- 예) HTTP 요청 메시지
- 요청 메시지도 body 본문을 가질 수 있다.

```json
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```

- 예) HTTP 응답 메시지

```json
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
	<body>...</body>
</html>
```

- HTTP 메시지 구조

```json
start-line : 시작 라인
header 헤더
empty line 공백 라인 (CRLF)
message body
```

### 🌻 5-1. 시작 라인(요청 메시지)

- start-line = **request-line** / status-line
- **request-line** = method SP(공백) request-target SP HTTP-version CRLF(엔터)
- 예) GET/search?q=hello&hl=ko HTTP/1.1
    - HTTP 메서드 (GET 조회)
    - 요청 대상(/search?q=hello&hl=ko)
    - HTTP Version(HTTP/1.1)
- **HTTP 메서드**
    - 종류 : GET, POST, PUT, DELETE…
    - 서버가 수행해야 할 동작을 지정한다.
    - GET : 리소스 조회
    - POST : 요청 내역 처리
- **요청 대상**
    - absolute-path[?query] (절대경로[?쿼리])
    - 절대경로= “/”로 시작하는 경로
    - 참고 : *, http://…?x=y와 같이 다른 유형의 경로지정 방법도 있다.
- **HTTP 버전**
    - HTTP Version을 나타낸다.

### 🌻 5-2. 시작 라인(응답 메시지)

- start-line = request-line / **status-line**
- **status-line** = HTTP-version SP status-code SP reason-phrase CRLF
- SP는 띄어쓰기이다.
- HTTP 버전
- HTTP 상태 코드 : 요청 성공, 실패를 나타냄
    - 200 : 성공
    - 400 : 클라이언트 요청 오류
    - 500 : 서버 내부 오류
- 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### 🌻 5-3. HTTP 헤더

- header-field = field-name “:” OWS field-value OWS
- OWS는 띄어쓰기 허용으로 띄어써도 되고 안띄어도 된다라는 의미이다.
- field-name은 대소문자 구문 없음
- 중요한 점은 `:` 은 반드시 붙여서 써야 한다.
- 예시)
    - Host: www.google.com
    - Content-Type: text/html;charset=UTF-8
    - Content-Length: 3423

### 🌻 5-4. HTTP 헤더의 용도

- HTTP 전송에 필요한 모든 부가정보
- 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보…
- 표준 헤더가 너무 많음.
- 필요시 임의의 헤더를 추가 가능하다.
    - helloworld: hihi

### 🌻 5-5. HTTP 메시지 바디의 용도

- 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능
- 예

```json
<html>
	<body>...</body>
</html>
```

### 🌻 5-6. HTTP 단순함 확장 가능

- HTTP는 단순하다. 스펙도 읽어볼만하다.
- HTTP 메시지도 매우 단순하다.
- 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술이다.

## 🍄 6. HTTP 정리

- HTTP 메시지에 모든 것을 전송
- HTTP 역사 HTTP/1.1을 기준으로 학습
- 클라이언트 서버 구조
- 무상태 프로토콜(Stateless)
- HTTP 메시지
- 단순함, 확장 가능
- **지금은 HTTP 시대**